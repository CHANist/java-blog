"use strict";(self.webpackChunkjava_blog=self.webpackChunkjava_blog||[]).push([[634],{7300:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return m}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],s={id:"bean_lifecycle_1",title:"4. Spring Bean Lifecycle Source Code Analysis\uff081\uff09",tags:["Java","Spring","\u5716\u9748\u8ab2\u5802"]},l=void 0,p={unversionedId:"spring/bean_lifecycle_1",id:"spring/bean_lifecycle_1",isDocsHomePage:!1,title:"4. Spring Bean Lifecycle Source Code Analysis\uff081\uff09",description:"How Spring scan the components",source:"@site/docs/spring/04-bean_lifecycle_first.md",sourceDirName:"spring",slug:"/spring/bean_lifecycle_1",permalink:"/java-blog/spring/bean_lifecycle_1",tags:[{label:"Java",permalink:"/java-blog/tags/java"},{label:"Spring",permalink:"/java-blog/tags/spring"},{label:"\u5716\u9748\u8ab2\u5802",permalink:"/java-blog/tags/\u5716\u9748\u8ab2\u5802"}],version:"current",lastUpdatedAt:1634179034,formattedLastUpdatedAt:"10/14/2021",sidebarPosition:4,frontMatter:{id:"bean_lifecycle_1",title:"4. Spring Bean Lifecycle Source Code Analysis\uff081\uff09",tags:["Java","Spring","\u5716\u9748\u8ab2\u5802"]},sidebar:"springSideBar"},d=[{value:"How Spring scan the components",id:"how-spring-scan-the-components",children:[]},{value:"How Spring uses Bean Definition Map to create non-lazy singleton bean",id:"how-spring-uses-bean-definition-map-to-create-non-lazy-singleton-bean",children:[]}],c={toc:d};function m(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"how-spring-scan-the-components"},"How Spring scan the components"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {\n    protected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n        Assert.notEmpty(basePackages, "At least one base package must be specified");\n        Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();\n        for (String basePackage : basePackages) {\n            // which refers to Step 1 - 5\n            Set<BeanDefinition> candidates = findCandidateComponents(basePackage);\n            for (BeanDefinition candidate : candidates) {\n                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n                candidate.setScope(scopeMetadata.getScopeName());\n                // step 6 starts\n                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n                if (candidate instanceof AbstractBeanDefinition) {\n                    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n                }\n                // set bean definition based on annotation, `@Lazy`, `@Primary`, `@DependsOn`, `@Role`, `@Description`\n                if (candidate instanceof AnnotatedBeanDefinition) {\n                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);\n                }\n                // step 6 ends\n                // step 7\n                if (checkCandidate(beanName, candidate)) {\n                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n                    // TODO: skip understanding first\n                    definitionHolder =\n                            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n                    beanDefinitions.add(definitionHolder);\n                    \n                    // step 8\n                    registerBeanDefinition(definitionHolder, this.registry);\n                }\n            }\n        }\n        return beanDefinitions;\n    }\n}\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"scan all classes inside the jar",(0,o.kt)("em",{parentName:"p"},"s")," using ",(0,o.kt)("inlineCode",{parentName:"p"},"classpath*:${basePackage}**/*.class")," and retrieve a list of Resources"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Note the use of ",(0,o.kt)("inlineCode",{parentName:"li"},"*")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"classpath*"),". "),(0,o.kt)("li",{parentName:"ul"},"[core method inside ",(0,o.kt)("inlineCode",{parentName:"li"},"ClassPathScanningCandidateComponentProvider::scanCandidateComponents"),"]"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"retrieve a list of MetdadataReader (\u5143\u6578\u64da\u8b80\u53d6\u5668) from Resources (Class File)"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"read meta data of the class, incl. class info, innotation, abstract, parent, ..."),(0,o.kt)("li",{parentName:"ul"},"which the reader uses ASM techique taught in previous lesson")))),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Support filtering of ",(0,o.kt)("inlineCode",{parentName:"p"},"MetdadataReader")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Resource")," based on End User Configuration"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"support ",(0,o.kt)("inlineCode",{parentName:"li"},"excludeFilters"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"includeFilters"),". In case if the same MetadataReader is placed in both excludeFilters and includeFilters, excludeFilters always take effective. By default, ",(0,o.kt)("inlineCode",{parentName:"li"},"includeFilters")," include ",(0,o.kt)("inlineCode",{parentName:"li"},"new AnnotationTypeFilter(Component.class)"),". "),(0,o.kt)("li",{parentName:"ul"},"in addition to ",(0,o.kt)("inlineCode",{parentName:"li"},"excludeFilters"),", Spring also support ",(0,o.kt)("inlineCode",{parentName:"li"},"@Conditional")," annotation in class, to allow only if certain condition is met, it will then be included, otherwise, it will be excluded. ")))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package org.springframework.context.annotation;\n\npublic class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware {\n    private final List<TypeFilter> includeFilters = new ArrayList<>();\n    private final List<TypeFilter> excludeFilters = new ArrayList<>();\n    \n    protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {\n        for (TypeFilter tf : this.excludeFilters) {\n            if (tf.match(metadataReader, getMetadataReaderFactory())) {\n                return false;\n            }\n        }\n        for (TypeFilter tf : this.includeFilters) {\n            if (tf.match(metadataReader, getMetadataReaderFactory())) {\n                return isConditionMatch(metadataReader);\n            }\n        }\n        return false;\n    }\n    \n    private boolean isConditionMatch(MetadataReader metadataReader) {\n        if (this.conditionEvaluator == null) {\n            this.conditionEvaluator =\n                    new ConditionEvaluator(getRegistry(), this.environment, this.resourcePatternResolver);\n        }\n        return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());\n    }\n    \n    public boolean shouldSkip(AnnotatedTypeMetadata metadata) {\n        return shouldSkip(metadata, null);\n    }\n    \n    public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) {\n        if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n            return false;\n        }\n\n        if (phase == null) {\n            if (metadata instanceof AnnotationMetadata &&\n                    ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {\n                return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n            }\n            return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n        }\n\n        List<Condition> conditions = new ArrayList<>();\n        for (String[] conditionClasses : getConditionClasses(metadata)) {\n            for (String conditionClass : conditionClasses) {\n                Condition condition = getCondition(conditionClass, this.context.getClassLoader());\n                conditions.add(condition);\n            }\n        }\n\n        AnnotationAwareOrderComparator.sort(conditions);\n\n        for (Condition condition : conditions) {\n            ConfigurationPhase requiredPhase = null;\n            if (condition instanceof ConfigurationCondition) {\n                requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();\n            }\n            if ((requiredPhase == null || requiredPhase == phase) && !condition.matches(this.context, metadata)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n")),(0,o.kt)("p",null,"   By default, it will register default filters, ",(0,o.kt)("inlineCode",{parentName:"p"},"includeFilters"),", as below code described. In normal case, it just includes all classes containing",(0,o.kt)("inlineCode",{parentName:"p"},"@Component")," annotation. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {\n    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) {\n        this(registry, true);\n    }\n    \n    // which is method inside ClassPathScanningCandidateComponentProvider\n    protected void registerDefaultFilters() {\n        this.includeFilters.add(new AnnotationTypeFilter(Component.class));\n        ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();\n        try {\n            this.includeFilters.add(new AnnotationTypeFilter(\n                    ((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));\n            logger.trace("JSR-250 \'javax.annotation.ManagedBean\' found and supported for component scanning");\n        }\n        catch (ClassNotFoundException ex) {\n            // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.\n        }\n        try {\n            this.includeFilters.add(new AnnotationTypeFilter(\n                    ((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));\n            logger.trace("JSR-330 \'javax.inject.Named\' annotation found and supported for component scanning");\n        }\n        catch (ClassNotFoundException ex) {\n            // JSR-330 API not available - simply skip.\n        }\n    }\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"This may be useful when we want to dynamically remove some beans")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"create a BeanDefinition from the list of",(0,o.kt)("inlineCode",{parentName:"p"},"MetdadataReader")," after filtering. "),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"beanClass is specified as ",(0,o.kt)("inlineCode",{parentName:"p"},"class name")," in ",(0,o.kt)("strong",{parentName:"p"},"string")," format, not ",(0,o.kt)("strong",{parentName:"p"},"class")," format"),(0,o.kt)("p",{parentName:"li"},"As the file is being found using ASM technique, which is a file format, not in class format. i.e. the class is not loaded yet. It will be loaded only when the class need to be instantiated. At that time, ",(0,o.kt)("inlineCode",{parentName:"p"},"beanclass")," will by of ",(0,o.kt)("inlineCode",{parentName:"p"},"class")," type instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," type anymore. "))),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class ScannedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition {\n    private final AnnotationMetadata metadata;\n    \n    // specify in AbstractBeanDefinition\n    @Nullable\n    private volatile Object beanClass;\n    \n    public ScannedGenericBeanDefinition(MetadataReader metadataReader) {\n        Assert.notNull(metadataReader, "MetadataReader must not be null");\n        this.metadata = metadataReader.getAnnotationMetadata();\n        setBeanClassName(this.metadata.getClassName());\n        setResource(metadataReader.getResource());\n    }\n}\n')))),(0,o.kt)("ol",{start:5},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Filtering of ",(0,o.kt)("inlineCode",{parentName:"p"},"MetdadataReader")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Resource")," again like 3, but ",(0,o.kt)("strong",{parentName:"p"},"based on whether the class can be instantiated ","[as per Java Specification]"),", rather than User Configuration"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"independent (top level class or static nested inner class)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"non-static nested inner class will be skipped even if it has @Component annotation. "))),(0,o.kt)("li",{parentName:"ul"},"concrete (not interface and not abstract class)"),(0,o.kt)("li",{parentName:"ul"},"abstract and has Lookup Annotation ",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"this is the strangest thing, by allowing abstract here, as Spring when used with ",(0,o.kt)("inlineCode",{parentName:"li"},"LookUp")," annotation, it will make use of ",(0,o.kt)("inlineCode",{parentName:"li"},"cglib"),", to create a subclass extending the original class, making abstract class feasible to be instantiated, thereby a feasible Spring bean. "),(0,o.kt)("li",{parentName:"ul"},"As it is based on ",(0,o.kt)("inlineCode",{parentName:"li"},"cglib")," to create a subclass, it requires the class not to be ",(0,o.kt)("inlineCode",{parentName:"li"},"final")," and the lookup method not to be ",(0,o.kt)("inlineCode",{parentName:"li"},"private"),". ")))),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {\n    // in ClassPathScanningCandidateComponentProvider superclass\n    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {\n        AnnotationMetadata metadata = beanDefinition.getMetadata();\n        return (metadata.isIndependent() && (metadata.isConcrete() ||\n                (metadata.isAbstract() && metadata.hasAnnotatedMethods(Lookup.class.getName()))));\n    }\n}\n")))),(0,o.kt)("ol",{start:6},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Up to this point, we have a list of BeanDefinition which contains the following information only. "),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"beanName (String)"),(0,o.kt)("li",{parentName:"ul"},"Resource (File)"),(0,o.kt)("li",{parentName:"ul"},"Metadata of the Class (e.g. annotation info, class name, interface implemented, ...)")),(0,o.kt)("p",{parentName:"li"},"But we still do not have any information We normally use. e.g. "),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"isLazy"),(0,o.kt)("li",{parentName:"ul"},"isSingleton"),(0,o.kt)("li",{parentName:"ul"},"...")),(0,o.kt)("p",{parentName:"li"},"Therefore, next we are going to convert these important information out. "),(0,o.kt)("p",{parentName:"li"},"Steps of Setting such BeanDefinitions"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"apply default bean definitions"),(0,o.kt)("li",{parentName:"ol"},"set bean definition should be autowire or not"),(0,o.kt)("li",{parentName:"ol"},"set bean definition based on ",(0,o.kt)("inlineCode",{parentName:"li"},"annotation"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Lazy"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Primary"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"DependsOn"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Role"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Description"),". ")))),(0,o.kt)("ol",{start:7},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"After setting beanDefinition, we are going to filter beanDefinition that ",(0,o.kt)("strong",{parentName:"p"},"has NOT been registered previously"),". "),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {\n    protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) throws IllegalStateException {\n        if (!this.registry.containsBeanDefinition(beanName)) {\n            return true;\n        }\n        // [1]\n        BeanDefinition existingDef = this.registry.getBeanDefinition(beanName);\n        BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();\n        if (originatingDef != null) {\n            existingDef = originatingDef;\n        }\n        if (isCompatible(beanDefinition, existingDef)) {\n            return false;\n        }\n        throw new ConflictingBeanDefinitionException("Annotation-specified bean name \'" + beanName +\n                "\' for bean class [" + beanDefinition.getBeanClassName() + "] conflicts with existing, " +\n                "non-compatible bean definition of same name and class [" + existingDef.getBeanClassName() + "]");\n    }\n}\n')))),(0,o.kt)("p",null,"   Note ","[1]"," exists because one may perform scanning of same class twice. If this is the case, then one class file will be converted to 2 beanDefinition, and run the above method. If no ",(0,o.kt)("inlineCode",{parentName:"p"},"isCompatible")," method checking is made, then it will throw exception and prevent Spring from starting up. "),(0,o.kt)("p",null,"   For example, one may perform the following: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"AnnotationConfigApplicationContext applicationContext = new AnnotationApplicationContext();\napplicationContext.register(AppConfig.class); // which is a class with @Configuration and @ComponentScan\napplicationContext.register(AppConfig1.class);  // which is a class with @Configuration and @ComponentScan, which may includes some class file which previously injected. \napplicationContext.refresh();\n")),(0,o.kt)("ol",{start:8},(0,o.kt)("li",{parentName:"ol"},"Finally, it will register bean definition into ",(0,o.kt)("inlineCode",{parentName:"li"},"DefaultListableBeanFactory#beanDefinitionMap"),", which is a Map of beanName and BeanDefinition and add into ",(0,o.kt)("inlineCode",{parentName:"li"},"DefaultListableBeanFactory#beanDefinitionNames"),", which is a list of beanNames. ")),(0,o.kt)("h3",{id:"how-spring-uses-bean-definition-map-to-create-non-lazy-singleton-bean"},"How Spring uses Bean Definition Map to create non-lazy singleton bean"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n    \n    /** List of bean definition names, in registration order. */\n    private volatile List<String> beanDefinitionNames = new ArrayList<>(256);\n    \n    /** Map of bean definition objects, keyed by bean name. */\n    private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);\n\n    @Override\n    public void preInstantiateSingletons() throws BeansException {\n        if (logger.isTraceEnabled()) {\n            logger.trace("Pre-instantiating singletons in " + this);\n        }\n\n        // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n        List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n        // Trigger initialization of all non-lazy singleton beans...\n        for (String beanName : beanNames) {\n            // step 1\n            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n            // step 2\n            if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n                if (isFactoryBean(beanName)) {\n                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n                    if (bean instanceof FactoryBean) {\n                        FactoryBean<?> factory = (FactoryBean<?>) bean;\n                        boolean isEagerInit;\n                        if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                            isEagerInit = AccessController.doPrivileged(\n                                    (PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,\n                                    getAccessControlContext());\n                        }\n                        else {\n                            isEagerInit = (factory instanceof SmartFactoryBean &&\n                                    ((SmartFactoryBean<?>) factory).isEagerInit());\n                        }\n                        if (isEagerInit) {\n                            getBean(beanName);\n                        }\n                    }\n                }\n                else {\n                    getBean(beanName);\n                }\n            }\n        }\n\n        // Trigger post-initialization callback for all applicable beans...\n        for (String beanName : beanNames) {\n            Object singletonInstance = getSingleton(beanName);\n            if (singletonInstance instanceof SmartInitializingSingleton) {\n                StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize")\n                        .tag("beanName", beanName);\n                SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n                if (System.getSecurityManager() != null) {\n                    AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                        smartSingleton.afterSingletonsInstantiated();\n                        return null;\n                    }, getAccessControlContext());\n                }\n                else {\n                    smartSingleton.afterSingletonsInstantiated();\n                }\n                smartInitialize.end();\n            }\n        }\n    }\n}\n')),(0,o.kt)("p",null,"For each beanDefinition found in scanning, do the following"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Merging bean definition"),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Usage")),(0,o.kt)("p",{parentName:"li"},"This is a function Spring provides that ",(0,o.kt)("strong",{parentName:"p"},"only Spring XML terminology used")," currently. "),(0,o.kt)("p",{parentName:"li"},"Before looking at the code, let see what it can do for us. "))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<bean id="john" class="com.thechanist.tuling.spring.ch04.parent.dto.User">\n        <property name="userId" value="A00000001" />\n        <property name="userName" value="John" />\n</bean>\n\n<bean id="johnVip" class="com.thechanist.tuling.spring.ch04.parent.dto.VIPUser" parent="john">\n    <property name="expiredDate" value="2021-10-13" />\n</bean>\n')),(0,o.kt)("p",null,"   By setting it in this way, bean ",(0,o.kt)("inlineCode",{parentName:"p"},"johnVip")," will get the ",(0,o.kt)("inlineCode",{parentName:"p"},"userId")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"userName")," value inherited from User bean. Actually Spring do that by calling the johnVip setter method, and does not require User to be a superclass of VIPUSer, though normally, it would be the case. "),(0,o.kt)("p",null,"   In addition, not only did Java gets used to bean property, but it can also inherit Spring BeanDefinition property. For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"scope"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<bean id="user" class="com.thechanist.tuling.spring.ch04.parent.dto.User" scope="prototype" />\n\n<bean id="vipUser" class="com.thechanist.tuling.spring.ch04.parent.dto.VIPUser" parent="user" />\n')),(0,o.kt)("p",null,"   P.S. "),(0,o.kt)("p",null,"   The Parent Bean usually used together with ",(0,o.kt)("inlineCode",{parentName:"p"},"BeanDefintion#isAbstract"),"  field, which means the bean is used for referrencing and should not be created. ","[which to me means abstract class (Super Class)]"),(0,o.kt)("p",null,"   ",(0,o.kt)("strong",{parentName:"p"},"Source Code")),(0,o.kt)("p",null,"   After looking at an example on how to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"BeanDefinition#getParentName"),", let's go back and look at how Spring make this work properly. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'package org.springframework.beans.factory.support;\n\npublic class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n        implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n    \n    // which the method is placed in org.springframework.beans.factory.support.AbstractBeanFactory superclass\n    protected RootBeanDefinition getMergedBeanDefinition(\n            String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)\n            throws BeanDefinitionStoreException {\n\n        synchronized (this.mergedBeanDefinitions) {\n            RootBeanDefinition mbd = null;\n            RootBeanDefinition previous = null;\n\n            // Check with full lock now in order to enforce the same merged instance.\n            if (containingBd == null) {\n                mbd = this.mergedBeanDefinitions.get(beanName);\n            }\n\n            if (mbd == null || mbd.stale) {\n                previous = mbd;\n                // step 1: for bean that does not have parent (normal bean), it just create a wrapper wrapping beanDefinition then done\n                if (bd.getParentName() == null) {\n                    // Use copy of given root bean definition.\n                    if (bd instanceof RootBeanDefinition) {\n                        mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();\n                    }\n                    else {\n                        mbd = new RootBeanDefinition(bd);\n                    }\n                }\n                // step 2: for bean having parent, we need custom logic to merge both bean and beanDefinition properties\n                else {\n                    // Child bean definition: needs to be merged with parent.\n                    BeanDefinition pbd;\n                    try {\n                        // step 3: transform bean parent name [as it needs to cater the case of FactoryBean]\n                        // but for normal bean that have parent, nothing is really doing in transformedBeanName\n                        String parentBeanName = transformedBeanName(bd.getParentName());\n                        if (!beanName.equals(parentBeanName)) {\n                            pbd = getMergedBeanDefinition(parentBeanName);\n                        }\n                        else {\n                            BeanFactory parent = getParentBeanFactory();\n                            if (parent instanceof ConfigurableBeanFactory) {\n                                pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);\n                            }\n                            else {\n                                throw new NoSuchBeanDefinitionException(parentBeanName,\n                                        "Parent name \'" + parentBeanName + "\' is equal to bean name \'" + beanName +\n                                                "\': cannot be resolved without a ConfigurableBeanFactory parent");\n                            }\n                        }\n                    }\n                    catch (NoSuchBeanDefinitionException ex) {\n                        throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,\n                                "Could not resolve parent bean definition \'" + bd.getParentName() + "\'", ex);\n                    }\n                    // Deep copy with overridden values.\n                    mbd = new RootBeanDefinition(pbd);\n                    mbd.overrideFrom(bd);\n                }\n\n                // Set default singleton scope, if not configured before.\n                if (!StringUtils.hasLength(mbd.getScope())) {\n                    mbd.setScope(SCOPE_SINGLETON);\n                }\n\n                // A bean contained in a non-singleton bean cannot be a singleton itself.\n                // Let\'s correct this on the fly here, since this might be the result of\n                // parent-child merging for the outer bean, in which case the original inner bean\n                // definition will not have inherited the merged outer bean\'s singleton status.\n                if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {\n                    mbd.setScope(containingBd.getScope());\n                }\n\n                // Cache the merged bean definition for the time being\n                // (it might still get re-merged later on in order to pick up metadata changes)\n                if (containingBd == null && isCacheBeanMetadata()) {\n                    this.mergedBeanDefinitions.put(beanName, mbd);\n                }\n            }\n            if (previous != null) {\n                copyRelevantMergedBeanDefinitionCaches(previous, mbd);\n            }\n            return mbd;\n        }\n    }\n')),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"check ",(0,o.kt)("inlineCode",{parentName:"li"},"!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()"),", where ",(0,o.kt)("inlineCode",{parentName:"li"},"isAbstract")," does not mean abstract class, as abstract class normally would not create a Spring Bean (with the exception of using ",(0,o.kt)("inlineCode",{parentName:"li"},"@Lookup"),")")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},'<bean id="A" class="com.thechanist.service.A" scope="prototype" abstract="true" />\n<bean id="B" class="com.thechanist.service.B" parent="A" />\n')),(0,o.kt)("p",null,"In this case, bean B will also of prototype scope, as it is inherited from bean A, unless B explicitly specify ",(0,o.kt)("inlineCode",{parentName:"p"},"scope"),". "),(0,o.kt)("hr",null),(0,o.kt)("h4",{id:"open-end-questions"},"Open End Questions"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"When should one use ",(0,o.kt)("inlineCode",{parentName:"p"},"@Lookup")," annotation?\nConsider the following cases, "),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class User {\n}\n\n@Service\npublic class UserService {   \n    @Lookup("user") // which specify beanName in @LookUp Annotation\n    public User getUser() {\n        return null;\n    }\n}\n')),(0,o.kt)("p",{parentName:"li"},"and the alternative, "),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Service\npublic class UserServiceTwo implements ApplicationContextAware {\n    private ApplicationContext applicationContext;\n    \n    public User getUser() {\n        return (User) applicationContext.getBean("user");\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}\n')),(0,o.kt)("p",{parentName:"li"},"Definitely, the alternative writes more code, but it does what ",(0,o.kt)("inlineCode",{parentName:"p"},"@Lookup")," does behind the scene without use of ",(0,o.kt)("inlineCode",{parentName:"p"},"cglib"),", i.e. allow ",(0,o.kt)("inlineCode",{parentName:"p"},"getUser")," method to be private and ",(0,o.kt)("inlineCode",{parentName:"p"},"UserService")," to be a final class. Though these conditions are not so important, what importance is that it looks much cleaner to me, what ",(0,o.kt)("inlineCode",{parentName:"p"},"getUser")," is really doing instead of returning a ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," here. What do you think? "))),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"What is ",(0,o.kt)("inlineCode",{parentName:"p"},"@Role")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@Primary")," used for? ")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Why ",(0,o.kt)("inlineCode",{parentName:"p"},"BeanDefinition")," does not have ",(0,o.kt)("inlineCode",{parentName:"p"},"beanName")," property? Why create another class, ",(0,o.kt)("inlineCode",{parentName:"p"},"BeanDefinitionHolder")," for storing ",(0,o.kt)("inlineCode",{parentName:"p"},"beanName"),"? ")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"What is the real usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"abstract")," in beanDefinition in real world? ")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Will Spring auto inject value for ",(0,o.kt)("inlineCode",{parentName:"p"},"@Autowired")," that is placed in superclass? ")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"@Autowired")," in super class field, and having ",(0,o.kt)("inlineCode",{parentName:"p"},"@Autowired")," in corresponding subclass setter method, will it work properly?")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Let's think about our TradeServer service, we need to set the size of ring buffer in every service that LMAX disruptor is used. But normally we would fix it as a value, but may want to change the default one after the application is built. How can we do that?\nUse of ",(0,o.kt)("inlineCode",{parentName:"p"},"@Value")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"superclass"),"? And in case if we need to override the property in one or two service, what should we do? ")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Spring allows end user to create a new scope, just like how Spring-WebMVC creates session scope. But can custom factory implementing ",(0,o.kt)("inlineCode",{parentName:"p"},"org.springframework.beans.factory.FactoryBean")," really work like that? ")),(0,o.kt)("li",{parentName:"ol"})),(0,o.kt)("hr",null))}m.isMDXComponent=!0}}]);